<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Python笔试面试题</title>
  
  <subtitle>人生苦短，我用Python</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.codingonway.com/"/>
  <updated>2017-09-25T15:38:24.704Z</updated>
  <id>http://www.codingonway.com/</id>
  
  <author>
    <name>大师兄</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试题116 链表中环的入口节点</title>
    <link href="http://www.codingonway.com/python-entry-node-in-list-loop.html"/>
    <id>http://www.codingonway.com/python-entry-node-in-list-loop.html</id>
    <published>2017-09-25T15:34:01.000Z</published>
    <updated>2017-09-25T15:38:24.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>一个链表中包含环，请找出该链表的环的入口节点。链表节点定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.next = <span class="keyword">None</span></div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>遍历链表将每一个节点放入列表中，如果已存在则它就是环的入口节点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">entry_node_of_loop</span><span class="params">(pHead)</span>:</span></div><div class="line">    <span class="keyword">if</span> pHead <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">    nodes = []</div><div class="line">    <span class="keyword">while</span> pHead:</div><div class="line">        <span class="keyword">if</span> pHead <span class="keyword">in</span> nodes:</div><div class="line">            <span class="keyword">return</span> pHead</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            nodes.append(pHead)</div><div class="line">            pHead = pHead.next</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;一个链表中包含环，请找出该链表的环的入口节点。链表节点定义如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, x)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.val = x&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.next = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://www.codingonway.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>面试题115 两个链表的第一个公共节点</title>
    <link href="http://www.codingonway.com/python-first-common-nodes-in-lists.html"/>
    <id>http://www.codingonway.com/python-first-common-nodes-in-lists.html</id>
    <published>2017-09-25T15:08:42.000Z</published>
    <updated>2017-09-25T15:18:26.678Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>输入两个链表，找出它们的第一个公共节点。链表节点定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.next = <span class="keyword">None</span></div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>分别把两个链表的节点放入两个栈里，这样两个链表的尾节点就位于两个栈的栈顶，接下来比较栈顶的节点是否相同。如果相同，则把栈顶弹出接着比较下一个栈顶，直到找到最后一个相同的节点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_first_common_node</span><span class="params">(pHead1, pHead2)</span>:</span></div><div class="line">    stack1 = []</div><div class="line">    stack2 = []</div><div class="line">    tmp = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span> pHead1:</div><div class="line">        stack1.append(pHead1)</div><div class="line">        pHead1 = pHead1.next</div><div class="line">    <span class="keyword">while</span> pHead2:</div><div class="line">        stack2.append(pHead2)</div><div class="line">        pHead2 = pHead2.next</div><div class="line">    <span class="keyword">while</span> stack1 <span class="keyword">and</span> stack2:</div><div class="line">        top1 = stack1.pop()</div><div class="line">        top2 = stack2.pop()</div><div class="line"></div><div class="line">        <span class="keyword">if</span> top1 == top2:</div><div class="line">            tmp = top1</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">break</span></div><div class="line">    <span class="keyword">return</span> tmp</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;输入两个链表，找出它们的第一个公共节点。链表节点定义如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, x)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.val = x&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.next = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://www.codingonway.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>面试题114 合并两个排序的链表</title>
    <link href="http://www.codingonway.com/python-merge-sorted-lists.html"/>
    <id>http://www.codingonway.com/python-merge-sorted-lists.html</id>
    <published>2017-09-25T09:13:40.000Z</published>
    <updated>2017-09-25T09:23:41.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。链表节点定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.next = <span class="keyword">None</span></div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>依次比较两个链表的结点值，较小的放入到结果链表中去，直到某一个链表为空。将剩余的某个不为空的链表加入结果链表中即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(pHead1, pHead2)</span>:</span></div><div class="line">    res = head = ListNode(<span class="number">0</span>)</div><div class="line">    <span class="keyword">while</span> pHead1 <span class="keyword">and</span> pHead2:</div><div class="line">        <span class="keyword">if</span> pHead1.val &lt;= pHead2.val:</div><div class="line">            head.next = pHead1</div><div class="line">            pHead1 = pHead1.next</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            head.next = pHead2</div><div class="line">            pHead2 = pHead2.next</div><div class="line">        head = head.next</div><div class="line">    head.next = pHead1 <span class="keyword">or</span> pHead2</div><div class="line">    <span class="keyword">return</span> res.next</div></pre></td></tr></table></figure><p>也可用递归实现（递归效率不高）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(pHead1, pHead2)</span>:</span></div><div class="line">    <span class="keyword">if</span> pHead1 <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">return</span> pHead2</div><div class="line">    <span class="keyword">if</span> pHead2 <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">return</span> pHead1</div><div class="line">    head = <span class="keyword">None</span></div><div class="line">    <span class="keyword">if</span> pHead1.val &lt;= pHead2.val:</div><div class="line">        head = pHead1</div><div class="line">        head.next = merge(pHead1.next, pHead2)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        head = pHead2</div><div class="line">        head.next = merge(pHead1, pHead2.next)</div><div class="line">    <span class="keyword">return</span> head</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。链表节点定义如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, x)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.val = x&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.next = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://www.codingonway.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>面试题113 反转链表</title>
    <link href="http://www.codingonway.com/python-reverse-list.html"/>
    <id>http://www.codingonway.com/python-reverse-list.html</id>
    <published>2017-09-25T07:15:07.000Z</published>
    <updated>2017-09-25T07:33:06.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。链表节点定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.next = <span class="keyword">None</span></div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>定义一个指针，初始值为None，始终指向反转后的链表的头节点，每次从链表中得到的节点的next都指向这个指针，同时这个指针前移指向当前获得节点，就实现了反转链表的功能。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_list</span><span class="params">(head)</span>:</span></div><div class="line">    tail = <span class="keyword">None</span></div><div class="line">    <span class="keyword">while</span> head:</div><div class="line">        tmp = head.next</div><div class="line">        head.next = tail</div><div class="line">        tail = head</div><div class="line">        head = tmp</div><div class="line">    <span class="keyword">return</span> tail</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。链表节点定义如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, x)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.val = x&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.next = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://www.codingonway.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>面试题112 链表中倒数第k个节点</title>
    <link href="http://www.codingonway.com/python-find-kth-node-from-end.html"/>
    <id>http://www.codingonway.com/python-find-kth-node-from-end.html</id>
    <published>2017-09-25T06:28:39.000Z</published>
    <updated>2017-09-25T06:48:51.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第一个节点。例如，一个链表有6个节点，从头结点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。链表节点定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.next = <span class="keyword">None</span></div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们可以定义两个指针，第一个指针从链表的头指针开始遍历向前走k-1步，第二个指针保持不动。从第k步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离始终保持在k-1，当第一个（走在前面的）指针到达链表的尾节点时，第二个（走在后面的）指针正好指向倒数第k个节点。要注意特殊测试用例：输入的是空链表，参数k为0，参数k大于链表的节点总数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_kth_to_end</span><span class="params">(head, k)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> k &lt;= <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">    p1 = p2 = head</div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(k<span class="number">-1</span>):</div><div class="line">        p1 = p1.next</div><div class="line">        <span class="keyword">if</span> p1 <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">    <span class="keyword">while</span> p1 <span class="keyword">and</span> p1.next:</div><div class="line">        p1 = p1.next</div><div class="line">        p2 = p2.next</div><div class="line">    <span class="keyword">return</span> p2</div></pre></td></tr></table></figure><p>或者，可以直接遍历完整的链表存入列表中，返回倒数第k个即可。代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_kth_to_tail</span><span class="params">(head, k)</span>:</span></div><div class="line">    l = []</div><div class="line">    <span class="keyword">while</span> head:</div><div class="line">        l.append(head)</div><div class="line">        head = head.next</div><div class="line">    <span class="keyword">if</span> k &lt;= <span class="number">0</span> <span class="keyword">or</span> k &gt; len(l):</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">    <span class="keyword">return</span> l[-k]</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第一个节点。例如，一个链表有6个节点，从头结点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。链表节点定义如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, x)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.val = x&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.next = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://www.codingonway.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>面试题111 从尾到头打印链表</title>
    <link href="http://www.codingonway.com/python-print-list-from-tail-to-head.html"/>
    <id>http://www.codingonway.com/python-print-list-from-tail-to-head.html</id>
    <published>2017-09-25T03:27:54.000Z</published>
    <updated>2017-09-25T04:08:09.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>输入一个链表的头结点，从尾到头反过来打印出每个节点的值。链表节点定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.next = <span class="keyword">None</span></div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>链表的遍历顺序是从头到尾，可输出打的顺序却是从尾到头。也就是说第一个遍历到的节点最后一个输出，而最后一个遍历到的节点第一个输出。这就是典型的”后进先出”，我们可以用栈来实现这种顺序。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_list_from_tail_to_head</span><span class="params">(listNode)</span>:</span></div><div class="line">    stack = []</div><div class="line">    <span class="keyword">while</span> listNode:</div><div class="line">        stack.append(listNode.val)</div><div class="line">        listNode = listNode.next</div><div class="line">    <span class="keyword">return</span> stack[::<span class="number">-1</span>]</div></pre></td></tr></table></figure><p>上述函数返回的是链表反序后的值组成的结果列表（如需打印自行写print语句）。<br>既然想到了用栈来实现这个函数，而递归在本质上就是一个栈结构，于是很自然地就想到用递归来实现。下面是递归版本的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_list_from_tail_to_head</span><span class="params">(listNode)</span>:</span></div><div class="line">    <span class="keyword">if</span> listNode:</div><div class="line">        print_list_from_tail_to_head(listNode.next)</div><div class="line">        print(listNode.val)</div></pre></td></tr></table></figure></p><p>上面的基于递归的代码看起来很简洁，但有一个问题，当链表非常长的时候，就会导致函数调用的层级很深，从而有可能导致栈溢出。显然用基于循环实现的代码的鲁棒性要好一些。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;输入一个链表的头结点，从尾到头反过来打印出每个节点的值。链表节点定义如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, x)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.val = x&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.next = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://www.codingonway.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>面试题110 栈的压入、弹出序列</title>
    <link href="http://www.codingonway.com/python-stack-push-pop-order.html"/>
    <id>http://www.codingonway.com/python-stack-push-pop-order.html</id>
    <published>2017-09-24T15:13:05.000Z</published>
    <updated>2017-09-24T15:47:46.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>输入两个整数序列，第一个序列表示栈的压入序列，请判断第二个序列是否为该栈的弹出序列。假设压入栈的所有数字均不相等。例如，序列{1,2,3,4,5}是某栈的压栈序列，序列{4,5,3,2,1}是该压栈序列对应的一个弹出序列，但{4,3,5,1,2}就不可能是该压栈序列的弹出序列。<br><a id="more"></a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>建立一个辅助栈，把输入的第一个序列中的数字依次压入该辅助栈，并按照第二个序列的顺序依次从该栈中弹出数字。如果下一个弹出的数字刚好是栈顶元素，那么直接弹出，如果下一个弹出的元素不在栈顶，则把压栈序列中还没有入栈的数字压入辅助栈，直到把需要弹出的数字压入栈顶为止。最终判断辅助栈是否为空，空则是弹出序列，非空则不是弹出序列。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_pop_order</span><span class="params">(push_v, pop_v)</span>:</span></div><div class="line">    stack = []</div><div class="line">    i = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> push_v:</div><div class="line">        stack.append(v)</div><div class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] == pop_v[i]:</div><div class="line">            stack.pop()</div><div class="line">            i += <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> len(stack) == <span class="number">0</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;输入两个整数序列，第一个序列表示栈的压入序列，请判断第二个序列是否为该栈的弹出序列。假设压入栈的所有数字均不相等。例如，序列{1,2,3,4,5}是某栈的压栈序列，序列{4,5,3,2,1}是该压栈序列对应的一个弹出序列，但{4,3,5,1,2}就不可能是该压栈序列的弹出序列。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="栈和队列" scheme="http://www.codingonway.com/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>面试题109 包含min函数的栈</title>
    <link href="http://www.codingonway.com/python-min-stack.html"/>
    <id>http://www.codingonway.com/python-min-stack.html</id>
    <published>2017-09-24T14:22:13.000Z</published>
    <updated>2017-09-24T14:35:17.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数。在该栈中，调用 min、push 及 pop 的时间复杂度都是O(1)。<br><a id="more"></a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>当每次向数据栈压入元素时，需先判断此时压入的元素是否比辅助栈栈顶元素要小，如果小的话，同时压入辅助栈，否则辅助栈栈顶元素压入辅助栈，保证辅助栈中始终是数据栈对应的最小元素组成的栈。出栈的话数据栈和辅助栈同时出栈即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.data_stack = []</div><div class="line">        self.min_stack = []</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, element)</span>:</span></div><div class="line">        self.data_stack.append(element)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.min_stack <span class="keyword">or</span> element &lt; self.min_stack[<span class="number">-1</span>]:</div><div class="line">            self.min_stack.append(element)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.min_stack.append(self.min_stack[<span class="number">-1</span>])</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></div><div class="line">        self.min_stack.pop()</div><div class="line">        <span class="keyword">return</span> self.data_stack.pop()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.min_stack[<span class="number">-1</span>]</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数。在该栈中，调用 min、push 及 pop 的时间复杂度都是O(1)。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="栈和队列" scheme="http://www.codingonway.com/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>面试题108 用两个栈实现队列</title>
    <link href="http://www.codingonway.com/python-implement-a-queue-using-two-stacks.html"/>
    <id>http://www.codingonway.com/python-implement-a-queue-using-two-stacks.html</id>
    <published>2017-09-24T13:01:41.000Z</published>
    <updated>2017-09-24T13:44:36.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个方法enqueue和dequeue，分别完成在队列尾部插入节点和在队列头部删除节点的功能。<br><a id="more"></a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>用两个后进先出（LIFO）的栈，实现一个先进先出（FIFO）的队列。队列尾部的插入元素操作可以用一个栈进行入栈操作代替，队列头部的删除操作需要用到第二个辅助栈，当第二个辅助栈中没有元素时，将第一个栈中所有元素弹出然后压入到第二个辅助栈中，这样辅助栈出栈操作即是队列头部的删除操作，如果第二个辅助栈中有元素，则直接出栈即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.stack1 = []</div><div class="line">        self.stack2 = []</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, element)</span>:</span></div><div class="line">        self.stack1.append(element)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</div><div class="line">            <span class="keyword">while</span> self.stack1:</div><div class="line">                self.stack2.append(self.stack1.pop())</div><div class="line">        <span class="keyword">return</span> self.stack2.pop()</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;用两个栈实现一个队列。队列的声明如下，请实现它的两个方法enqueue和dequeue，分别完成在队列尾部插入节点和在队列头部删除节点的功能。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="栈和队列" scheme="http://www.codingonway.com/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>面试题107 基于列表实现栈和队列</title>
    <link href="http://www.codingonway.com/python-implement-data-stucture-stack-and-queue-base-on-list.html"/>
    <id>http://www.codingonway.com/python-implement-data-stucture-stack-and-queue-base-on-list.html</id>
    <published>2017-09-23T02:47:58.000Z</published>
    <updated>2017-09-23T03:12:30.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种后进先出（LIFO）的数据结构，只能在一端（栈顶）插入和删除元素。<br>在Python中列表的<code>append()</code>和<code>pop()</code>方法分别对应的就是向栈顶插入和删除元素，因此Python中列表可以作为栈这种数据结构。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>stack = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>stack.append(<span class="number">5</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>stack.append(<span class="number">6</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>stack</div><div class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>stack.pop()</div><div class="line"><span class="number">6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>stack.pop()</div><div class="line"><span class="number">5</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>stack.pop()</div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>stack</div><div class="line">[<span class="number">2</span>, <span class="number">3</span>]</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是一种先进先出（FIFO）的数据结构，在一端（队尾）插入元素，在另一端（队首）删除元素。<br>列表的<code>insert()</code>和<code>pop()</code>方法，虽然可以实现队列的先进先出的特性，但是在列表头部插入和删除元素都不高效，因为需要移动列表后面的所有元素。列表的特点是在尾部插入和删除元素时间复杂度O(1)，而在头部插入和删除元素时间复杂度O(n)。<br>为了实现队列，用<code>collections.deque</code>双端队列，其特点是可以在两端快速插入和删除元素，时间复杂度都为O(1)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>queue = deque([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>queue.append(<span class="string">'D'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>queue.append(<span class="string">'E'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>queue</div><div class="line">deque([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>queue.popleft()</div><div class="line"><span class="string">'A'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>queue.popleft()</div><div class="line"><span class="string">'B'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>queue</div><div class="line">deque([<span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>])</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p><p>双端队列<code>collections.deque</code>也是基于列表实现的，Python中内置的数据结构很丰富，我们可以基于其扩展实现我们需要的数据结构，而不应该从0去手动实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h2&gt;&lt;p&gt;栈是一种后进先出（LIFO）的数据结构，只能在一端（栈顶）插入和删除元素。&lt;br&gt;在Python中列表的&lt;code&gt;append()&lt;/code&gt;和&lt;code&gt;pop()&lt;/code&gt;方法分别对应的就是向栈顶插入和删除元素，因此Python中列表可以作为栈这种数据结构。&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;stack = [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;stack.append(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;stack.append(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;stack&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;stack.pop()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;stack.pop()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;stack.pop()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;stack&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="栈和队列" scheme="http://www.codingonway.com/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>面试题106 跳台阶、变态跳台阶问题</title>
    <link href="http://www.codingonway.com/python-recursive-and-iterator-problems.html"/>
    <id>http://www.codingonway.com/python-recursive-and-iterator-problems.html</id>
    <published>2017-09-23T01:53:57.000Z</published>
    <updated>2017-09-23T02:15:24.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h2><p>问题描述：</p><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><a id="more"></a><p>分析：<br>初始值很容易得到，当 n &gt; 2 时，跳上n级台阶最后一步无外乎两种情况，从第n-1级跳一级跳上来，或是从第n-2级跳两级跳上来，因此很容易得到如下递推公式。</p><blockquote><p>F（1）= 1<br>F（2）= 2<br>F（n）= F（n-1）+ F（n-2）（n &gt; 2）</p></blockquote><p>代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">jump_floor</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    prev, curr = <span class="number">1</span>, <span class="number">2</span></div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1</span>, n):</div><div class="line">        prev, curr = curr, prev+curr</div><div class="line">    <span class="keyword">return</span> prev</div></pre></td></tr></table></figure></p><h2 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h2><p>问题描述：</p><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><p>分析：<br>相比普通跳台阶，这次青蛙一次可以跳任意级，基于上述思路，很容易得到如下递推公式。</p><blockquote><p>F（1）= 1<br>F（2）= 2<br>F（n）= F（n-1）+ F（n-2）+ … + F（2）+ F（1）+ 1 = 2 **（n-1）</p></blockquote><p>代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">jump_floor</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    <span class="keyword">return</span> <span class="number">2</span>**(n<span class="number">-1</span>)</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;跳台阶&quot;&gt;&lt;a href=&quot;#跳台阶&quot; class=&quot;headerlink&quot; title=&quot;跳台阶&quot;&gt;&lt;/a&gt;跳台阶&lt;/h2&gt;&lt;p&gt;问题描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="递归和循环" scheme="http://www.codingonway.com/tags/%E9%80%92%E5%BD%92%E5%92%8C%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>面试题105 数值取整(四舍五入、向上取整、向下取整、向0取整)</title>
    <link href="http://www.codingonway.com/python-convert-number-to-integer.html"/>
    <id>http://www.codingonway.com/python-convert-number-to-integer.html</id>
    <published>2017-09-21T09:30:20.000Z</published>
    <updated>2017-09-21T09:53:31.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数值取整"><a href="#数值取整" class="headerlink" title="数值取整"></a>数值取整</h2><blockquote><p>四舍五入：内置函数round()<br>向零取整：内置函数int()<br>向上取整：math模块中的math.ceil()<br>向下取整：math模块中的math.floor()</p></blockquote><a id="more"></a><h2 id="四舍五入"><a href="#四舍五入" class="headerlink" title="四舍五入"></a>四舍五入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">3.2</span>)</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">-3.8</span>)</div><div class="line"><span class="number">-4</span></div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure><p>同时，round()函数向偶取整，即：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">0.5</span>)</div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">-0.5</span>)</div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">1.5</span>)</div><div class="line"><span class="number">2</span></div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p><p>注意，在Python2中round()函数返回浮点数，在Python3中返回整数。</p><h2 id="向0取整"><a href="#向0取整" class="headerlink" title="向0取整"></a>向0取整</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">3.2</span>)</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">-3.8</span>)</div><div class="line"><span class="number">-3</span></div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure><h2 id="向上取整"><a href="#向上取整" class="headerlink" title="向上取整"></a>向上取整</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>math.ceil(<span class="number">3.2</span>)</div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>math.ceil(<span class="number">-3.8</span>)</div><div class="line"><span class="number">-3</span></div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure><h2 id="向下取整"><a href="#向下取整" class="headerlink" title="向下取整"></a>向下取整</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>math.floor(<span class="number">3.8</span>)</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>math.floor(<span class="number">-3.2</span>)</div><div class="line"><span class="number">-4</span></div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数值取整&quot;&gt;&lt;a href=&quot;#数值取整&quot; class=&quot;headerlink&quot; title=&quot;数值取整&quot;&gt;&lt;/a&gt;数值取整&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;四舍五入：内置函数round()&lt;br&gt;向零取整：内置函数int()&lt;br&gt;向上取整：math模块中的math.ceil()&lt;br&gt;向下取整：math模块中的math.floor()&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="基础数据类型" scheme="http://www.codingonway.com/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
      <category term="数字" scheme="http://www.codingonway.com/tags/%E6%95%B0%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>面试题104 反转字符串、元组、列表等序列类型</title>
    <link href="http://www.codingonway.com/reverse-sequence-type-str-tuple-list-in-python.html"/>
    <id>http://www.codingonway.com/reverse-sequence-type-str-tuple-list-in-python.html</id>
    <published>2017-09-21T06:41:21.000Z</published>
    <updated>2017-09-21T07:00:55.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Python中如何反转序列类型，比如反转常见序列类型字符串、元组、列表等？<br><a id="more"></a></p><h2 id="reversed-seq-内置函数"><a href="#reversed-seq-内置函数" class="headerlink" title="reversed(seq)内置函数"></a>reversed(seq)内置函数</h2><p>reversed(seq)内置函数用于将序列反转，返回一个迭代器。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># reverse list</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x  = list(reversed(l))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x</div><div class="line">[<span class="string">'C'</span>, <span class="string">'B'</span>, <span class="string">'A'</span>]</div><div class="line"></div><div class="line"><span class="comment"># reverse tuple</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>y = tuple(reversed(t))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>y</div><div class="line">(<span class="string">'C'</span>, <span class="string">'B'</span>, <span class="string">'A'</span>)</div><div class="line"></div><div class="line"><span class="comment"># reverse str</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'ABC'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>z = <span class="string">''</span>.join(reversed(s))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>z</div><div class="line"><span class="string">'CBA'</span></div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p><p>注意一点，reversed(seq)函数并没有改变seq序列本身，如需改动seq序列本身，将结果赋值给seq即可。以列表为例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># reverse list in place</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l  = list(reversed(l))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l</div><div class="line">[<span class="string">'C'</span>, <span class="string">'B'</span>, <span class="string">'A'</span>]</div></pre></td></tr></table></figure></p><h2 id="使用切片操作-1"><a href="#使用切片操作-1" class="headerlink" title="使用切片操作[::-1]"></a>使用切片操作[::-1]</h2><p>切片用法<code>[&lt;start&gt;:&lt;end&gt;:&lt;step&gt;]</code>，其中start默认值是0，end默认值是len(seq)，step默认值是1。此处省略了start和end，步长为-1代表反向切片（从右向左每次前进1步）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># reverse list</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x = l[::<span class="number">-1</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x</div><div class="line">[<span class="string">'C'</span>, <span class="string">'B'</span>, <span class="string">'A'</span>]</div><div class="line"></div><div class="line"><span class="comment"># reverse tuple</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>y = t[::<span class="number">-1</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>y</div><div class="line">(<span class="string">'C'</span>, <span class="string">'B'</span>, <span class="string">'A'</span>)</div><div class="line"></div><div class="line"><span class="comment"># reverse str</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'ABC'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>z = s[::<span class="number">-1</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>z</div><div class="line"><span class="string">'CBA'</span></div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p><p>由于切片操作返回的是与序列类型相同的新对象，也不会改变原始的序列，如需改变，将结果赋值原始序列。以字符串为例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># reverse str in place</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'ABC'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = s[::<span class="number">-1</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s</div><div class="line"><span class="string">'CBA'</span></div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p><h2 id="列表的原地反转reverse-方法"><a href="#列表的原地反转reverse-方法" class="headerlink" title="列表的原地反转reverse()方法"></a>列表的原地反转reverse()方法</h2><p>由于列表是可变对象，其reverse()方法可以原地反转列表中元素，无返回值或者说是返回None（如果一个函数或方法对对象进行的是就地改动，那它就应该返回None，好让调用者知道传入的参数发生了变动，而且并未产生新的对象。例如，random.shuffle函数也遵守了这个惯例。），元组和字符串都是不可变对象，因此都没有reverse()方法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># reverse list in place</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l.reverse()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l</div><div class="line">[<span class="string">'C'</span>, <span class="string">'B'</span>, <span class="string">'A'</span>]</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;Python中如何反转序列类型，比如反转常见序列类型字符串、元组、列表等？&lt;br&gt;
    
    </summary>
    
      <category term="基础数据类型" scheme="http://www.codingonway.com/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
      <category term="序列" scheme="http://www.codingonway.com/tags/%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>面试题103 求斐波那契数列的第n项</title>
    <link href="http://www.codingonway.com/python-get-fibonacci-n-number.html"/>
    <id>http://www.codingonway.com/python-get-fibonacci-n-number.html</id>
    <published>2017-09-20T09:10:36.000Z</published>
    <updated>2017-09-20T09:23:26.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>求斐波那契数列的第n项，要求时间复杂度<code>O(n)</code>，空间复杂度<code>O(1)</code>。<br>在数学上，费波那契数列是以递归的方法来定义：</p><blockquote><p>F（0）= 0<br>F（1）= 1<br>F（n）= F（n-1）+ F（n-2） （n &gt;= 2）</p></blockquote><p><strong>特别指出</strong>：0不是第一项，而是第零项。<br><a id="more"></a></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归的方法虽然简明清晰，但是开销太大，效率太低，会有大量的重复计算。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</div><div class="line">        <span class="keyword">return</span> n</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>) + Fibonacci(n<span class="number">-2</span>)</div></pre></td></tr></table></figure></p><h2 id="递归的优化版本"><a href="#递归的优化版本" class="headerlink" title="递归的优化版本"></a>递归的优化版本</h2><p>优化版本的递归，把每次计算过的值都保存在字典中，避免大量重复计算。但却需要一个额外的辅助字典（空间复杂度<code>O(n)</code>）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">known = &#123;<span class="number">0</span>:<span class="number">0</span>, <span class="number">1</span>:<span class="number">1</span>&#125;</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> known:</div><div class="line">        known[n] = Fibonacci(n<span class="number">-1</span>) + Fibonacci(n<span class="number">-2</span>)</div><div class="line">    <span class="keyword">return</span> known[n]</div></pre></td></tr></table></figure></p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>能用递归解决的问题在优化上的思路必然要考虑循环，而且用循环实现，效率高，开销小。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(n)</span>:</span></div><div class="line">    prev, curr = <span class="number">0</span>, <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</div><div class="line">        prev, curr = curr, prev+curr</div><div class="line">    <span class="keyword">return</span> prev</div></pre></td></tr></table></figure></p><p>此方法时间复杂度<code>O(n)</code>，空间复杂度<code>O(1)</code>，是最佳的解决方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;求斐波那契数列的第n项，要求时间复杂度&lt;code&gt;O(n)&lt;/code&gt;，空间复杂度&lt;code&gt;O(1)&lt;/code&gt;。&lt;br&gt;在数学上，费波那契数列是以递归的方法来定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;F（0）= 0&lt;br&gt;F（1）= 1&lt;br&gt;F（n）= F（n-1）+ F（n-2） （n &amp;gt;= 2）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;特别指出&lt;/strong&gt;：0不是第一项，而是第零项。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="递归和循环" scheme="http://www.codingonway.com/tags/%E9%80%92%E5%BD%92%E5%92%8C%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>面试题102 矩阵转置(二维列表行列互换)</title>
    <link href="http://www.codingonway.com/matrix-transpose-in-python.html"/>
    <id>http://www.codingonway.com/matrix-transpose-in-python.html</id>
    <published>2017-09-19T10:54:16.000Z</published>
    <updated>2017-09-19T13:44:00.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有二维列表如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">matrix = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]</div></pre></td></tr></table></figure></p><p>转置（行列互换）后的结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="嵌套的列表推导式"><a href="#嵌套的列表推导式" class="headerlink" title="嵌套的列表推导式"></a>嵌套的列表推导式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>matrix = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>matrix_t = [[row[col] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> col <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>]))]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>matrix_t</div><div class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure><p>原理很简单：先循环列，在固定列上循环每一行。</p><h2 id="zip迭代-map映射"><a href="#zip迭代-map映射" class="headerlink" title="zip迭代 + map映射"></a>zip迭代 + map映射</h2><p>在 Python2 中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>matrix = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>matrix_t = map(list, zip(*matrix))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>matrix_t</div><div class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p><p>如在 Python3 中，map函数返回的是迭代器不是列表，将结果用list函数构造成列表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>matrix = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>matrix_t = list(map(list, zip(*matrix)))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>matrix_t</div><div class="line">[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>], [<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>]]</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p><p>原理也很清晰：先用zip并行迭代每一个列表，然后再用map将迭代后的元组转成列表。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;有二维列表如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;matrix = [[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;], [&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;], [&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;]]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;转置（行列互换）后的结果如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;], [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;], [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;], [&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;]]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="基础数据类型" scheme="http://www.codingonway.com/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
      <category term="列表" scheme="http://www.codingonway.com/tags/%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>面试题101 交换字典的键和值</title>
    <link href="http://www.codingonway.com/swap-dict-keys-and-values.html"/>
    <id>http://www.codingonway.com/swap-dict-keys-and-values.html</id>
    <published>2017-09-19T03:11:16.000Z</published>
    <updated>2017-09-19T13:43:53.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>如何交换字典的键和值？有如下字典：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">d = &#123;<span class="string">'A'</span> : <span class="number">1</span>, <span class="string">'B'</span> : <span class="number">2</span>, <span class="string">'C'</span> : <span class="number">3</span>&#125;</div></pre></td></tr></table></figure></p><p>交换后的结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="number">1</span>: <span class="string">'A'</span>, <span class="number">2</span>: <span class="string">'B'</span>, <span class="number">3</span>: <span class="string">'C'</span>&#125;</div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'A'</span> : <span class="number">1</span>, <span class="string">'B'</span> : <span class="number">2</span>, <span class="string">'C'</span> : <span class="number">3</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d1 = &#123;v:k <span class="keyword">for</span> k,v <span class="keyword">in</span> d.items()&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d1</div><div class="line">&#123;<span class="number">1</span>: <span class="string">'A'</span>, <span class="number">2</span>: <span class="string">'B'</span>, <span class="number">3</span>: <span class="string">'C'</span>&#125;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure><h2 id="生成器表达式-dict"><a href="#生成器表达式-dict" class="headerlink" title="生成器表达式 + dict()"></a>生成器表达式 + dict()</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'A'</span> : <span class="number">1</span>, <span class="string">'B'</span> : <span class="number">2</span>, <span class="string">'C'</span> : <span class="number">3</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d2 = dict((v,k) <span class="keyword">for</span> k,v <span class="keyword">in</span> d.items())</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d2</div><div class="line">&#123;<span class="number">1</span>: <span class="string">'A'</span>, <span class="number">2</span>: <span class="string">'B'</span>, <span class="number">3</span>: <span class="string">'C'</span>&#125;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure><h2 id="zip-dict"><a href="#zip-dict" class="headerlink" title="zip() + dict()"></a>zip() + dict()</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'A'</span> : <span class="number">1</span>, <span class="string">'B'</span> : <span class="number">2</span>, <span class="string">'C'</span> : <span class="number">3</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d3 = dict(zip(d.values(), d.keys()))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d3</div><div class="line">&#123;<span class="number">1</span>: <span class="string">'A'</span>, <span class="number">2</span>: <span class="string">'B'</span>, <span class="number">3</span>: <span class="string">'C'</span>&#125;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>字典中的键必须是可哈希的不可变对象，值可以是任意对象。因此交换字典的键和值可能会有两种意外情况。<br>无法交换字典的键和值，原因是字典的值是不可哈希的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'A'</span> : <span class="number">1</span>, <span class="string">'B'</span> : [<span class="number">2</span>], <span class="string">'C'</span> : <span class="number">3</span> &#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d4 = &#123;v:k <span class="keyword">for</span> k,v <span class="keyword">in</span> d.items()&#125;</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;dictcomp&gt;</div><div class="line">TypeError: unhashable type: <span class="string">'list'</span></div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p><p>交换后字典元素数变少，原因是有重复值，字典的键具有唯一性。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'A'</span> : <span class="number">1</span>, <span class="string">'B'</span> : <span class="number">1</span>, <span class="string">'C'</span> : <span class="number">1</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d5 = &#123;v:k <span class="keyword">for</span> k,v <span class="keyword">in</span> d.items()&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d5</div><div class="line">&#123;<span class="number">1</span>: <span class="string">'B'</span>&#125;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;如何交换字典的键和值？有如下字典：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;d = &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;A&#39;&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;B&#39;&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;C&#39;&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;交换后的结果如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;A&#39;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;B&#39;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;C&#39;&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="基础数据类型" scheme="http://www.codingonway.com/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
      <category term="字典" scheme="http://www.codingonway.com/tags/%E5%AD%97%E5%85%B8/"/>
    
  </entry>
  
</feed>
