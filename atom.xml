<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Python笔试面试题</title>
  
  <subtitle>人生苦短，我用Python</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.codingonway.com/"/>
  <updated>2017-10-07T15:36:19.415Z</updated>
  <id>http://www.codingonway.com/</id>
  
  <author>
    <name>大师兄</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试题126 去除列表中重复元素</title>
    <link href="http://www.codingonway.com/python-remove-list-duplicate-items.html"/>
    <id>http://www.codingonway.com/python-remove-list-duplicate-items.html</id>
    <published>2017-10-07T14:52:55.000Z</published>
    <updated>2017-10-07T15:36:19.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>如何去除列表中重复元素，如果要同时保证去重后元素顺序不变呢？<br><a id="more"></a></p><h2 id="集合set"><a href="#集合set" class="headerlink" title="集合set()"></a>集合set()</h2><p>集合的特点就是无序、不重复，因此可以用set()构造方法将列表转成集合，然后再用list()转成列表。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = list(set(l1))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l2</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p><h2 id="字典keys"><a href="#字典keys" class="headerlink" title="字典keys()"></a>字典keys()</h2><p>字典的键具有唯一性，因此可以用将列表转成字典（键为列表元素值，值为None），再把字典的keys转成列表。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = &#123;&#125;.fromkeys(l1).keys()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l2</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p><p>注意：python3中字典的keys()方法返回的不在是列表，而是类似集合的dict_keys对象，因此需要用list()构造方法再转成列表。<br><strong>上述两种方法得到的结果都不能保证原有的元素顺序，下面介绍两种方法去重后保持元素原有顺序</strong></p><h2 id="列表的index法作为排序的key"><a href="#列表的index法作为排序的key" class="headerlink" title="列表的index法作为排序的key"></a>列表的index法作为排序的key</h2><p>列表中元素值的索引可以用index()方法得到，因此可以作为列表排序方法sort()的key。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = list(set(l1))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l2.sort(key=l1.index)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l2</div><div class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p><p>也可以用sorted函数，注意sorted函数返回的是新列表并没有改变原始列表，而列表的sort方法返回值是None，因为其改变就地排序即改变原始输入列表。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = sorted(set(l1), key=l1.index)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l2</div><div class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p><h2 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h2><p>遍历列表逐一判断元素是否在辅助列表中即可：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">l1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>]</div><div class="line">l2 = []</div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> l1:</div><div class="line">    <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> l2:</div><div class="line">        l2.append(item)</div></pre></td></tr></table></figure></p><p>也可以考虑用集合加生成器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">l1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dedupe</span><span class="params">(items)</span>:</span></div><div class="line">    seen = set()</div><div class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</div><div class="line">        <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> seen:</div><div class="line">            seen.add(item)</div><div class="line">            <span class="keyword">yield</span> item</div><div class="line"></div><div class="line">l2 = list(dedupe(l1))</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;如何去除列表中重复元素，如果要同时保证去重后元素顺序不变呢？&lt;br&gt;
    
    </summary>
    
      <category term="基础数据类型" scheme="http://www.codingonway.com/categories/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
      <category term="列表" scheme="http://www.codingonway.com/tags/%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>面试题125 树的子结构</title>
    <link href="http://www.codingonway.com/python-sub-structure-in-tree.html"/>
    <id>http://www.codingonway.com/python-sub-structure-in-tree.html</id>
    <published>2017-09-27T09:09:45.000Z</published>
    <updated>2017-09-27T09:26:05.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>输入两颗二叉树A和B，判断B是不是A的子结构，我们约定空树不是任意一个树的子结构。二叉树节点的定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.left = <span class="keyword">None</span></div><div class="line">        self.right = <span class="keyword">None</span></div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>要查找树A中是否存在和树B结构一样的子树，我们可以分成两步。第一步，在树A中找到和树B的根节点的值一样的节点R。第二步，判断树A中以R为根节点的子树是不是包含和树B一样的结构。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span><span class="params">(self, A, B)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> <span class="keyword">not</span> B:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">return</span> self.IsSubtree(A, B) <span class="keyword">or</span> self.HasSubtree(A.left, B) <span class="keyword">or</span> self.HasSubtree(A.right, B)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsSubtree</span><span class="params">(self, A, B)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> B:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> A.val != B.val:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">return</span> self.IsSubtree(A.left, B.left) <span class="keyword">and</span> self.IsSubtree(A.right, B.right)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;输入两颗二叉树A和B，判断B是不是A的子结构，我们约定空树不是任意一个树的子结构。二叉树节点的定义如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TreeNode&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, x)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.val = x&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.left = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.right = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="http://www.codingonway.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>面试题124 对称的二叉树</title>
    <link href="http://www.codingonway.com/python-symmetrical-binary-tree.html"/>
    <id>http://www.codingonway.com/python-symmetrical-binary-tree.html</id>
    <published>2017-09-27T03:21:48.000Z</published>
    <updated>2017-09-27T03:26:51.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>请实现一个函数，用来判断一颗二叉树是不是对称的。如果一颗二叉树和它的镜像一样，那么它是对称的。二叉树节点的定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.left = <span class="keyword">None</span></div><div class="line">        self.right = <span class="keyword">None</span></div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>把输入的二叉树复制成两颗二叉树，分别比较其中一颗树的左子树和另一颗树的右子树是否对称，一棵树的右子树和另一颗树的左子树是否对称，即可判断输入的二叉树是否对称的。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetrical</span><span class="params">(self, pRoot)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.isSym(pRoot, pRoot)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSym</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></div><div class="line">        <span class="keyword">if</span> pRoot1 <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> pRoot2 <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">if</span> pRoot1 <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> pRoot2 <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">if</span> pRoot1.val != pRoot2.val:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">return</span> self.isSym(pRoot1.left, pRoot2.right) <span class="keyword">and</span> self.isSym(pRoot1.right, pRoot2.left)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;请实现一个函数，用来判断一颗二叉树是不是对称的。如果一颗二叉树和它的镜像一样，那么它是对称的。二叉树节点的定义如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TreeNode&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, x)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.val = x&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.left = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.right = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="http://www.codingonway.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>面试题123 平衡二叉树</title>
    <link href="http://www.codingonway.com/python-balanced-binary-tree.html"/>
    <id>http://www.codingonway.com/python-balanced-binary-tree.html</id>
    <published>2017-09-27T02:56:05.000Z</published>
    <updated>2017-09-27T03:03:12.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>输入一颗二叉树的根节点，判断该二叉树是不是平衡二叉树。如果某二叉树中任意节点的左、右子树的深度相差不超过1，那么它就是一颗平衡二叉树。二叉树节点的定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.left = <span class="keyword">None</span></div><div class="line">        self.right = <span class="keyword">None</span></div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>依据平衡二叉树的定义，只要判断任意节点的左、右子树深度差是否超过1，即可判断这颗二叉树是否是平衡二叉树。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalancedTree</span><span class="params">(self, pRoot)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">if</span> abs(self.TreeDepth(pRoot.left)-self.TreeDepth(pRoot.right)) &gt; <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">return</span> self.IsBalancedTree(pRoot.left) <span class="keyword">and</span> self.IsBalancedTree(pRoot.right)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth</span><span class="params">(self, pRoot)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="keyword">return</span> max(self.TreeDepth(pRoot.left),self.TreeDepth(pRoot.right)) + <span class="number">1</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;输入一颗二叉树的根节点，判断该二叉树是不是平衡二叉树。如果某二叉树中任意节点的左、右子树的深度相差不超过1，那么它就是一颗平衡二叉树。二叉树节点的定义如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TreeNode&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, x)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.val = x&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.left = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.right = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="http://www.codingonway.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>面试题122 二叉树的深度</title>
    <link href="http://www.codingonway.com/python-tree-depth.html"/>
    <id>http://www.codingonway.com/python-tree-depth.html</id>
    <published>2017-09-27T02:15:24.000Z</published>
    <updated>2017-09-27T02:20:10.702Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>输入一颗二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。二叉树节点的定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.left = <span class="keyword">None</span></div><div class="line">        self.right = <span class="keyword">None</span></div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>树的深度其实就是左、右子树深度的较大值再加1。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tree_depth</span><span class="params">(pRoot)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    <span class="keyword">return</span> max(tree_depth(pRoot.left),tree_depth(pRoot.right)) + <span class="number">1</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;输入一颗二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。二叉树节点的定义如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TreeNode&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, x)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.val = x&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.left = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.right = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="http://www.codingonway.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>面试题121 从上往下打印二叉树</title>
    <link href="http://www.codingonway.com/python-print-tree-from-top-to-bottom.html"/>
    <id>http://www.codingonway.com/python-print-tree-from-top-to-bottom.html</id>
    <published>2017-09-26T09:30:29.000Z</published>
    <updated>2017-09-26T09:38:44.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。二叉树节点的定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.left = <span class="keyword">None</span></div><div class="line">        self.right = <span class="keyword">None</span></div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>实际上本题考查的就是二叉树的按层遍历算法。每次打印一个节点的时候，如果该节点有子节点，则把该节点的子节点放入到一个队列的末尾。接下来到队列的头部取出最早进入队列的节点，重复前面的打印操作，直到队列中所有元素都被打印出来。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</div><div class="line"><span class="comment"># 返回从上到下每个节点值列表，例：[1,2,3]</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_from_top_to_bottom</span><span class="params">(root)</span>:</span></div><div class="line">    result = []</div><div class="line">    queue = deque()</div><div class="line">    <span class="keyword">if</span> root:</div><div class="line">        queue.append(root)</div><div class="line">        <span class="keyword">while</span> queue:</div><div class="line">            current = queue.popleft()</div><div class="line">            result.append(current.val)</div><div class="line">            <span class="keyword">if</span> current.left:</div><div class="line">                queue.append(current.left)</div><div class="line">            <span class="keyword">if</span> current.right:</div><div class="line">                queue.append(current.right)</div><div class="line">    <span class="keyword">return</span> result</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;从上往下打印出二叉树的每个节点，同层节点从左至右打印。二叉树节点的定义如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TreeNode&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, x)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.val = x&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.left = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.right = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="http://www.codingonway.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>面试题120 二叉树的镜像</title>
    <link href="http://www.codingonway.com/python-mirror-of-binary-tree.html"/>
    <id>http://www.codingonway.com/python-mirror-of-binary-tree.html</id>
    <published>2017-09-26T09:01:31.000Z</published>
    <updated>2017-09-26T09:06:11.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。二叉树节点的定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.left = <span class="keyword">None</span></div><div class="line">        self.right = <span class="keyword">None</span></div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>交换二叉树的左右子节点，即得到了二叉树的镜像。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mirror</span><span class="params">(root)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">    root.left, root.right = root.right, root.left</div><div class="line">    mirror(root.left)</div><div class="line">    mirror(root.right)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;操作给定的二叉树，将其变换为源二叉树的镜像。二叉树节点的定义如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TreeNode&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, x)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.val = x&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.left = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.right = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="http://www.codingonway.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>面试题119 二叉树的下一个节点</title>
    <link href="http://www.codingonway.com/python-next-node-in-binary-trees.html"/>
    <id>http://www.codingonway.com/python-next-node-in-binary-trees.html</id>
    <published>2017-09-26T08:05:42.000Z</published>
    <updated>2017-09-26T08:18:31.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一颗二叉树和其中的一个节点，请找出中序遍历的下一个节点并将其返回。树中的节点除了有两个分别指向左、右子节点的指针，还有一个指向父节点的指针。二叉树节点定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.left = <span class="keyword">None</span></div><div class="line">        self.right = <span class="keyword">None</span></div><div class="line">        self.parent = <span class="keyword">None</span></div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>如果一个节点有右子树，那么它的下一个节点就是它的右子树的最左子节点。</li><li>如果一个节点没有右子树，并且这个节点是它父节点的左子节点，那么它的下一个节点就是它的父节点。</li><li>如果一个节点没有右子树，并且这个节点是它父节点的右子节点，那么就要沿着指向父节点的指针一直向上遍历，直到找到一个是它父节点的左子节点的节点。如果这样的节点存在，那么这个节点的父节点就是我们要找的下一个节点。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_next</span><span class="params">(pNode)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pNode:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> pNode.right:</div><div class="line">        res = pNode.right</div><div class="line">        <span class="keyword">while</span> res.left:</div><div class="line">            res = res.left</div><div class="line">        <span class="keyword">return</span> res</div><div class="line"></div><div class="line">    <span class="keyword">while</span> pNode.parent:</div><div class="line">        <span class="keyword">if</span> pNode == pNode.parent.left:</div><div class="line">            <span class="keyword">return</span> pNode.parent</div><div class="line">        pNode = pNode.parent</div><div class="line">    <span class="keyword">return</span> <span class="keyword">None</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;给定一颗二叉树和其中的一个节点，请找出中序遍历的下一个节点并将其返回。树中的节点除了有两个分别指向左、右子节点的指针，还有一个指向父节点的指针。二叉树节点定义如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TreeLinkNode&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, x)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.val = x&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.left = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.right = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.parent = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="http://www.codingonway.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>面试题118 重建二叉树</title>
    <link href="http://www.codingonway.com/python-construct-binary-tree.html"/>
    <id>http://www.codingonway.com/python-construct-binary-tree.html</id>
    <published>2017-09-26T06:54:35.000Z</published>
    <updated>2017-09-26T07:16:28.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如，输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并输出它的头结点。二叉树节点的定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.left = <span class="keyword">None</span></div><div class="line">        self.right = <span class="keyword">None</span></div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在二叉树的前序遍历序列中，第一个数字总是树的根节点的值。但在中序遍历序列中，根节点的值在序列的中间，左子树的节点的值位于根节点的值的左边，而右子树的节点的值位于根节点的值的右边。因此我们需要扫描中序遍历序列，找到根节点的值，继而我们也就分别找到了左、右子树的前序遍历序列和中序遍历序列，我们可以用同样的方法分别构建左右、子树。也就是说，接下来的事情可以用递归的方法去完成。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">re_construct_binary_tree</span><span class="params">(pre, tin)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> tin:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">    root = TreeNode(pre[<span class="number">0</span>])</div><div class="line">    i = tin.index(root.val)</div><div class="line">    root.left = re_construct_binary_tree(pre[<span class="number">1</span>:i+<span class="number">1</span>],tin[:i])</div><div class="line">    root.right = re_construct_binary_tree(pre[i+<span class="number">1</span>:],tin[i+<span class="number">1</span>:])</div><div class="line">    <span class="keyword">return</span> root</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如，输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并输出它的头结点。二叉树节点的定义如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TreeNode&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, x)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.val = x&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.left = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.right = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="http://www.codingonway.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>面试题117 删除链表中重复的节点</title>
    <link href="http://www.codingonway.com/python-delete-dupicate-node.html"/>
    <id>http://www.codingonway.com/python-delete-dupicate-node.html</id>
    <published>2017-09-25T16:05:26.000Z</published>
    <updated>2017-09-25T16:15:54.899Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在一个排序的链表中，存在重复的节点，请删除该链表中重复的节点，重复的节点不保留，返回链表头指针。链表节点定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.next = <span class="keyword">None</span></div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>定义两个指针，一个指向当前节点，一个指向当前节点的前一个节点，每次比较当前节点和当前节点的下一个节点值是否相等，相等则是重复节点删除，同时通过前一个节点保证链表没有重复的节点连在一起。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_duplication</span><span class="params">(pHead)</span>:</span></div><div class="line">    <span class="keyword">if</span> pHead <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">    prev = <span class="keyword">None</span></div><div class="line">    curr = pHead</div><div class="line">    <span class="keyword">while</span> curr:</div><div class="line">        <span class="keyword">if</span> curr.next <span class="keyword">and</span> curr.val == curr.next.val:</div><div class="line">            val = curr.val</div><div class="line">            <span class="keyword">while</span> curr <span class="keyword">and</span> curr.val == val:</div><div class="line">                <span class="keyword">if</span> <span class="keyword">not</span> prev:</div><div class="line">                    pHead = curr.next</div><div class="line">                    curr = curr.next</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    curr = curr.next</div><div class="line">                    prev.next = curr</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            prev = curr</div><div class="line">            curr = curr.next</div><div class="line">    <span class="keyword">return</span> pHead</div></pre></td></tr></table></figure><p>还可以遍历链表每一个节点，把链表的值存在列表中，遍历列表，如值不重复则构造此节点加入链表中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_duplication</span><span class="params">(pHead)</span>:</span></div><div class="line">    nodes = []</div><div class="line">    head = result = ListNode(<span class="number">0</span>)</div><div class="line">    <span class="keyword">while</span> pHead:</div><div class="line">        nodes.append(pHead.val)</div><div class="line">        pHead = pHead.next</div><div class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> nodes:</div><div class="line">        <span class="keyword">if</span> nodes.count(val) == <span class="number">1</span>:</div><div class="line">            head.next = ListNode(val)</div><div class="line">            head = head.next</div><div class="line">    <span class="keyword">return</span> result.next</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;在一个排序的链表中，存在重复的节点，请删除该链表中重复的节点，重复的节点不保留，返回链表头指针。链表节点定义如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, x)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.val = x&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.next = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://www.codingonway.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>面试题116 链表中环的入口节点</title>
    <link href="http://www.codingonway.com/python-entry-node-in-list-loop.html"/>
    <id>http://www.codingonway.com/python-entry-node-in-list-loop.html</id>
    <published>2017-09-25T15:34:01.000Z</published>
    <updated>2017-09-25T15:38:24.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>一个链表中包含环，请找出该链表的环的入口节点。链表节点定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.next = <span class="keyword">None</span></div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>遍历链表将每一个节点放入列表中，如果已存在则它就是环的入口节点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">entry_node_of_loop</span><span class="params">(pHead)</span>:</span></div><div class="line">    <span class="keyword">if</span> pHead <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">    nodes = []</div><div class="line">    <span class="keyword">while</span> pHead:</div><div class="line">        <span class="keyword">if</span> pHead <span class="keyword">in</span> nodes:</div><div class="line">            <span class="keyword">return</span> pHead</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            nodes.append(pHead)</div><div class="line">            pHead = pHead.next</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;一个链表中包含环，请找出该链表的环的入口节点。链表节点定义如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, x)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.val = x&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.next = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://www.codingonway.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>面试题115 两个链表的第一个公共节点</title>
    <link href="http://www.codingonway.com/python-first-common-nodes-in-lists.html"/>
    <id>http://www.codingonway.com/python-first-common-nodes-in-lists.html</id>
    <published>2017-09-25T15:08:42.000Z</published>
    <updated>2017-09-25T15:18:26.678Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>输入两个链表，找出它们的第一个公共节点。链表节点定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.next = <span class="keyword">None</span></div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>分别把两个链表的节点放入两个栈里，这样两个链表的尾节点就位于两个栈的栈顶，接下来比较栈顶的节点是否相同。如果相同，则把栈顶弹出接着比较下一个栈顶，直到找到最后一个相同的节点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_first_common_node</span><span class="params">(pHead1, pHead2)</span>:</span></div><div class="line">    stack1 = []</div><div class="line">    stack2 = []</div><div class="line">    tmp = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span> pHead1:</div><div class="line">        stack1.append(pHead1)</div><div class="line">        pHead1 = pHead1.next</div><div class="line">    <span class="keyword">while</span> pHead2:</div><div class="line">        stack2.append(pHead2)</div><div class="line">        pHead2 = pHead2.next</div><div class="line">    <span class="keyword">while</span> stack1 <span class="keyword">and</span> stack2:</div><div class="line">        top1 = stack1.pop()</div><div class="line">        top2 = stack2.pop()</div><div class="line"></div><div class="line">        <span class="keyword">if</span> top1 == top2:</div><div class="line">            tmp = top1</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">break</span></div><div class="line">    <span class="keyword">return</span> tmp</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;输入两个链表，找出它们的第一个公共节点。链表节点定义如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, x)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.val = x&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.next = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://www.codingonway.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>面试题114 合并两个排序的链表</title>
    <link href="http://www.codingonway.com/python-merge-sorted-lists.html"/>
    <id>http://www.codingonway.com/python-merge-sorted-lists.html</id>
    <published>2017-09-25T09:13:40.000Z</published>
    <updated>2017-09-25T09:23:41.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。链表节点定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.next = <span class="keyword">None</span></div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>依次比较两个链表的结点值，较小的放入到结果链表中去，直到某一个链表为空。将剩余的某个不为空的链表加入结果链表中即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(pHead1, pHead2)</span>:</span></div><div class="line">    res = head = ListNode(<span class="number">0</span>)</div><div class="line">    <span class="keyword">while</span> pHead1 <span class="keyword">and</span> pHead2:</div><div class="line">        <span class="keyword">if</span> pHead1.val &lt;= pHead2.val:</div><div class="line">            head.next = pHead1</div><div class="line">            pHead1 = pHead1.next</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            head.next = pHead2</div><div class="line">            pHead2 = pHead2.next</div><div class="line">        head = head.next</div><div class="line">    head.next = pHead1 <span class="keyword">or</span> pHead2</div><div class="line">    <span class="keyword">return</span> res.next</div></pre></td></tr></table></figure><p>也可用递归实现（递归效率不高）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(pHead1, pHead2)</span>:</span></div><div class="line">    <span class="keyword">if</span> pHead1 <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">return</span> pHead2</div><div class="line">    <span class="keyword">if</span> pHead2 <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">return</span> pHead1</div><div class="line">    head = <span class="keyword">None</span></div><div class="line">    <span class="keyword">if</span> pHead1.val &lt;= pHead2.val:</div><div class="line">        head = pHead1</div><div class="line">        head.next = merge(pHead1.next, pHead2)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        head = pHead2</div><div class="line">        head.next = merge(pHead1, pHead2.next)</div><div class="line">    <span class="keyword">return</span> head</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。链表节点定义如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, x)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.val = x&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.next = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://www.codingonway.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>面试题113 反转链表</title>
    <link href="http://www.codingonway.com/python-reverse-list.html"/>
    <id>http://www.codingonway.com/python-reverse-list.html</id>
    <published>2017-09-25T07:15:07.000Z</published>
    <updated>2017-09-25T07:33:06.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。链表节点定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.next = <span class="keyword">None</span></div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>定义一个指针，初始值为None，始终指向反转后的链表的头节点，每次从链表中得到的节点的next都指向这个指针，同时这个指针前移指向当前获得节点，就实现了反转链表的功能。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse_list</span><span class="params">(head)</span>:</span></div><div class="line">    tail = <span class="keyword">None</span></div><div class="line">    <span class="keyword">while</span> head:</div><div class="line">        tmp = head.next</div><div class="line">        head.next = tail</div><div class="line">        tail = head</div><div class="line">        head = tmp</div><div class="line">    <span class="keyword">return</span> tail</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。链表节点定义如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, x)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.val = x&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.next = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://www.codingonway.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>面试题112 链表中倒数第k个节点</title>
    <link href="http://www.codingonway.com/python-find-kth-node-from-end.html"/>
    <id>http://www.codingonway.com/python-find-kth-node-from-end.html</id>
    <published>2017-09-25T06:28:39.000Z</published>
    <updated>2017-09-25T06:48:51.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第一个节点。例如，一个链表有6个节点，从头结点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。链表节点定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.next = <span class="keyword">None</span></div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们可以定义两个指针，第一个指针从链表的头指针开始遍历向前走k-1步，第二个指针保持不动。从第k步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离始终保持在k-1，当第一个（走在前面的）指针到达链表的尾节点时，第二个（走在后面的）指针正好指向倒数第k个节点。要注意特殊测试用例：输入的是空链表，参数k为0，参数k大于链表的节点总数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_kth_to_end</span><span class="params">(head, k)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> k &lt;= <span class="number">0</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">    p1 = p2 = head</div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(k<span class="number">-1</span>):</div><div class="line">        p1 = p1.next</div><div class="line">        <span class="keyword">if</span> p1 <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">    <span class="keyword">while</span> p1 <span class="keyword">and</span> p1.next:</div><div class="line">        p1 = p1.next</div><div class="line">        p2 = p2.next</div><div class="line">    <span class="keyword">return</span> p2</div></pre></td></tr></table></figure><p>或者，可以直接遍历完整的链表存入列表中，返回倒数第k个即可。代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_kth_to_tail</span><span class="params">(head, k)</span>:</span></div><div class="line">    l = []</div><div class="line">    <span class="keyword">while</span> head:</div><div class="line">        l.append(head)</div><div class="line">        head = head.next</div><div class="line">    <span class="keyword">if</span> k &lt;= <span class="number">0</span> <span class="keyword">or</span> k &gt; len(l):</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">    <span class="keyword">return</span> l[-k]</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第一个节点。例如，一个链表有6个节点，从头结点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。链表节点定义如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, x)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.val = x&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.next = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://www.codingonway.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>面试题111 从尾到头打印链表</title>
    <link href="http://www.codingonway.com/python-print-list-from-tail-to-head.html"/>
    <id>http://www.codingonway.com/python-print-list-from-tail-to-head.html</id>
    <published>2017-09-25T03:27:54.000Z</published>
    <updated>2017-09-25T04:08:09.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>输入一个链表的头结点，从尾到头反过来打印出每个节点的值。链表节点定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.next = <span class="keyword">None</span></div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>链表的遍历顺序是从头到尾，可输出打的顺序却是从尾到头。也就是说第一个遍历到的节点最后一个输出，而最后一个遍历到的节点第一个输出。这就是典型的”后进先出”，我们可以用栈来实现这种顺序。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_list_from_tail_to_head</span><span class="params">(listNode)</span>:</span></div><div class="line">    stack = []</div><div class="line">    <span class="keyword">while</span> listNode:</div><div class="line">        stack.append(listNode.val)</div><div class="line">        listNode = listNode.next</div><div class="line">    <span class="keyword">return</span> stack[::<span class="number">-1</span>]</div></pre></td></tr></table></figure><p>上述函数返回的是链表反序后的值组成的结果列表（如需打印自行写print语句）。<br>既然想到了用栈来实现这个函数，而递归在本质上就是一个栈结构，于是很自然地就想到用递归来实现。下面是递归版本的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_list_from_tail_to_head</span><span class="params">(listNode)</span>:</span></div><div class="line">    <span class="keyword">if</span> listNode:</div><div class="line">        print_list_from_tail_to_head(listNode.next)</div><div class="line">        print(listNode.val)</div></pre></td></tr></table></figure></p><p>上面的基于递归的代码看起来很简洁，但有一个问题，当链表非常长的时候，就会导致函数调用的层级很深，从而有可能导致栈溢出。显然用基于循环实现的代码的鲁棒性要好一些。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;输入一个链表的头结点，从尾到头反过来打印出每个节点的值。链表节点定义如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, x)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.val = x&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.next = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://www.codingonway.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>面试题110 栈的压入、弹出序列</title>
    <link href="http://www.codingonway.com/python-stack-push-pop-order.html"/>
    <id>http://www.codingonway.com/python-stack-push-pop-order.html</id>
    <published>2017-09-24T15:13:05.000Z</published>
    <updated>2017-09-24T15:47:46.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>输入两个整数序列，第一个序列表示栈的压入序列，请判断第二个序列是否为该栈的弹出序列。假设压入栈的所有数字均不相等。例如，序列{1,2,3,4,5}是某栈的压栈序列，序列{4,5,3,2,1}是该压栈序列对应的一个弹出序列，但{4,3,5,1,2}就不可能是该压栈序列的弹出序列。<br><a id="more"></a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>建立一个辅助栈，把输入的第一个序列中的数字依次压入该辅助栈，并按照第二个序列的顺序依次从该栈中弹出数字。如果下一个弹出的数字刚好是栈顶元素，那么直接弹出，如果下一个弹出的元素不在栈顶，则把压栈序列中还没有入栈的数字压入辅助栈，直到把需要弹出的数字压入栈顶为止。最终判断辅助栈是否为空，空则是弹出序列，非空则不是弹出序列。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_pop_order</span><span class="params">(push_v, pop_v)</span>:</span></div><div class="line">    stack = []</div><div class="line">    i = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> push_v:</div><div class="line">        stack.append(v)</div><div class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] == pop_v[i]:</div><div class="line">            stack.pop()</div><div class="line">            i += <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> len(stack) == <span class="number">0</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;输入两个整数序列，第一个序列表示栈的压入序列，请判断第二个序列是否为该栈的弹出序列。假设压入栈的所有数字均不相等。例如，序列{1,2,3,4,5}是某栈的压栈序列，序列{4,5,3,2,1}是该压栈序列对应的一个弹出序列，但{4,3,5,1,2}就不可能是该压栈序列的弹出序列。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="栈和队列" scheme="http://www.codingonway.com/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>面试题109 包含min函数的栈</title>
    <link href="http://www.codingonway.com/python-min-stack.html"/>
    <id>http://www.codingonway.com/python-min-stack.html</id>
    <published>2017-09-24T14:22:13.000Z</published>
    <updated>2017-09-24T14:35:17.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数。在该栈中，调用 min、push 及 pop 的时间复杂度都是O(1)。<br><a id="more"></a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>当每次向数据栈压入元素时，需先判断此时压入的元素是否比辅助栈栈顶元素要小，如果小的话，同时压入辅助栈，否则辅助栈栈顶元素压入辅助栈，保证辅助栈中始终是数据栈对应的最小元素组成的栈。出栈的话数据栈和辅助栈同时出栈即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.data_stack = []</div><div class="line">        self.min_stack = []</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, element)</span>:</span></div><div class="line">        self.data_stack.append(element)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.min_stack <span class="keyword">or</span> element &lt; self.min_stack[<span class="number">-1</span>]:</div><div class="line">            self.min_stack.append(element)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.min_stack.append(self.min_stack[<span class="number">-1</span>])</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></div><div class="line">        self.min_stack.pop()</div><div class="line">        <span class="keyword">return</span> self.data_stack.pop()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.min_stack[<span class="number">-1</span>]</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数。在该栈中，调用 min、push 及 pop 的时间复杂度都是O(1)。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="栈和队列" scheme="http://www.codingonway.com/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>面试题108 用两个栈实现队列</title>
    <link href="http://www.codingonway.com/python-implement-a-queue-using-two-stacks.html"/>
    <id>http://www.codingonway.com/python-implement-a-queue-using-two-stacks.html</id>
    <published>2017-09-24T13:01:41.000Z</published>
    <updated>2017-09-24T13:44:36.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个方法enqueue和dequeue，分别完成在队列尾部插入节点和在队列头部删除节点的功能。<br><a id="more"></a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>用两个后进先出（LIFO）的栈，实现一个先进先出（FIFO）的队列。队列尾部的插入元素操作可以用一个栈进行入栈操作代替，队列头部的删除操作需要用到第二个辅助栈，当第二个辅助栈中没有元素时，将第一个栈中所有元素弹出然后压入到第二个辅助栈中，这样辅助栈出栈操作即是队列头部的删除操作，如果第二个辅助栈中有元素，则直接出栈即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.stack1 = []</div><div class="line">        self.stack2 = []</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, element)</span>:</span></div><div class="line">        self.stack1.append(element)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</div><div class="line">            <span class="keyword">while</span> self.stack1:</div><div class="line">                self.stack2.append(self.stack1.pop())</div><div class="line">        <span class="keyword">return</span> self.stack2.pop()</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;用两个栈实现一个队列。队列的声明如下，请实现它的两个方法enqueue和dequeue，分别完成在队列尾部插入节点和在队列头部删除节点的功能。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="栈和队列" scheme="http://www.codingonway.com/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>面试题107 基于列表实现栈和队列</title>
    <link href="http://www.codingonway.com/python-implement-data-stucture-stack-and-queue-base-on-list.html"/>
    <id>http://www.codingonway.com/python-implement-data-stucture-stack-and-queue-base-on-list.html</id>
    <published>2017-09-23T02:47:58.000Z</published>
    <updated>2017-09-23T03:12:30.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种后进先出（LIFO）的数据结构，只能在一端（栈顶）插入和删除元素。<br>在Python中列表的<code>append()</code>和<code>pop()</code>方法分别对应的就是向栈顶插入和删除元素，因此Python中列表可以作为栈这种数据结构。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>stack = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>stack.append(<span class="number">5</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>stack.append(<span class="number">6</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>stack</div><div class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>stack.pop()</div><div class="line"><span class="number">6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>stack.pop()</div><div class="line"><span class="number">5</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>stack.pop()</div><div class="line"><span class="number">4</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>stack</div><div class="line">[<span class="number">2</span>, <span class="number">3</span>]</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p><a id="more"></a><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是一种先进先出（FIFO）的数据结构，在一端（队尾）插入元素，在另一端（队首）删除元素。<br>列表的<code>insert()</code>和<code>pop()</code>方法，虽然可以实现队列的先进先出的特性，但是在列表头部插入和删除元素都不高效，因为需要移动列表后面的所有元素。列表的特点是在尾部插入和删除元素时间复杂度O(1)，而在头部插入和删除元素时间复杂度O(n)。<br>为了实现队列，用<code>collections.deque</code>双端队列，其特点是可以在两端快速插入和删除元素，时间复杂度都为O(1)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>queue = deque([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>queue.append(<span class="string">'D'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>queue.append(<span class="string">'E'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>queue</div><div class="line">deque([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>queue.popleft()</div><div class="line"><span class="string">'A'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>queue.popleft()</div><div class="line"><span class="string">'B'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>queue</div><div class="line">deque([<span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>])</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p><p>双端队列<code>collections.deque</code>也是基于列表实现的，Python中内置的数据结构很丰富，我们可以基于其扩展实现我们需要的数据结构，而不应该从0去手动实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h2&gt;&lt;p&gt;栈是一种后进先出（LIFO）的数据结构，只能在一端（栈顶）插入和删除元素。&lt;br&gt;在Python中列表的&lt;code&gt;append()&lt;/code&gt;和&lt;code&gt;pop()&lt;/code&gt;方法分别对应的就是向栈顶插入和删除元素，因此Python中列表可以作为栈这种数据结构。&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;stack = [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;stack.append(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;stack.append(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;stack&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;stack.pop()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;stack.pop()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;stack.pop()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;stack&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构和算法" scheme="http://www.codingonway.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="栈和队列" scheme="http://www.codingonway.com/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
